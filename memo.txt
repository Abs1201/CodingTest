#define ll long long
const int mxN = 1e5;

set -> distinct
이거 이진트리형태이고, 알아서 정렬되므로 append가 아닌 insert임.
set<array<int,2>> s;
s.insert({1,2});
s.lower_bound(2); return beq 2;

map
이건 레드블랙_이진트리, 알아서 정렬됨 -> insert();
if(mp.find(x-a)!=mp.end()){
    ~~
    return 0;
}

find(v.begin(), v.end(), value);
이거는 <algorightm.h>의 find.
map.find(value)
이거는 <map.h>의 find 
애초에 map은 범위가 정해지지 않음. 그래서 따로 잇다.  


sort(pointer, pointer) // 정적배열
sort(iterator, iterator) // array<>..
ex) a[mxN], b[mxN]
sort(a, a+n);

array vs vector : 이거때메 따로 정적이나 동적할당으로 배열 잘 안쓰는듯.
array길이는 미리 정해져야함. ex) array<int, 2> ar; (o)
                                array<int, n> ar; (x)
즉, append 불가.
Function)
    ar.at(1) = 5;
    ar.size(); // sizeof 이건 일반 배열.
    <algorithm> library로
    sort(ar.begin(), ar.end()) 오름차순
    sort(ar.rbegin(), ar.rend()) 내림차순

sort(str.begin(), str.end(), std::greater<int>());


if (str.find(c) != std::string::npos) {
        std::cout << "Character found" << std::endl;
    } else {
        std::cout << "Character not found" << std::endl;
    }



// arduino
void setup(){
    pinMode(13, OUTPUT);
}

void loop(){
    digitalWrite(13, HIGH);
    delay(1000);
    digitalWrite(13, LOW);
    delay(1000);
}